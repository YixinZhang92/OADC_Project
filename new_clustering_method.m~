close all; clear all; clc;
infile = 'testdata.txt';
global xc yc zc vec_plane xb_old yb_old zb_old xs ys zs N Nc
global xt yt zt Nt xb yb zb lambda3
global L W xv yv zv L_old W_old xv_old yv_old zv_old fscale


%***************** Read Catalog of Hypocenters ****************************
read_catalog(infile);

% Random hypocenters have been created - Rotate the data into the
% geographical coordinate system in order of rake, dip, strike

% rotate into rake direction
tic
nhypos = length(xs);
strikes = 0:5:175;%[45 135];%pos is anticlockwise. 
%The solution is not sensitive to angles greater than 180. 181 deg is the same as 1 deg
dips = 0:5:90;%[90 45];

width= 1; % width of the depth slider when determining the number of EQs in each block.
min_eqs_for_a_cluster = 30;

% Initializing array %analy_old = analy;
analy = [xs' ys' zs' zeros(nhypos,1) zeros(nhypos,1) zeros(nhypos,1) ...
    zeros(nhypos,1) zeros(nhypos,1) zeros(nhypos,1) zeros(nhypos,1)  zeros(nhypos,1)]; %7 - no of eqs, 8 - dist at max eqs

unique_value = 0;

for j = 1: length(strikes)
    for jj = 1:length(dips)
        
        % Getting a unique value
        unique_value = unique_value + 1; 
        
        % ------------------------------------------------------------------------
        % Analyzing for each combination of strike and dip. We do not need the
        % rake.
        con=pi/180.;
        strike=strikes(j).*con;
        dip=dips(jj).*con;

        % extracting the xs, ys and zs because their relative location will change
        % during the analysis.
        xs_now = analy(:,1)';
        ys_now = analy(:,2)';
        zs_now = analy(:,3)';

        xs_now = xs_now - mean(xs_now); % removing the mean for the rotation to be about origins. 
        ys_now = ys_now - mean(ys_now);
        zs_now = zs_now - mean(zs_now);

        R=[xs_now ; ys_now ;zs_now];

        % rotate into strike direction
        %Dstrike=[ sin(strike)  -cos(strike) 0 ; cos(strike) sin(strike) 0 ; 0 0 1];
        Dstrike=[ cos(strike)  -sin(strike) 0 ; sin(strike) cos(strike) 0 ; 0 0 1];

        Rstrike=Dstrike*R;

        rxp(1:nhypos)=Rstrike(1,1:nhypos);
        ryp(1:nhypos)=Rstrike(2,1:nhypos);
        rzp(1:nhypos)=Rstrike(3,1:nhypos);

%         figure;
%         plot3(rxp,ryp,rzp,'o');
%         axis equal;
%         title('rotation into strike');
%         xlabel('X km');
%         ylabel('Y km');
%         zlabel('Z km');


        % rotate into dip direction
        Rstrike(1,1:nhypos) = Rstrike(1,1:nhypos)-mean(Rstrike(1,1:nhypos));
        Rstrike(2,1:nhypos) = Rstrike(2,1:nhypos)-mean(Rstrike(2,1:nhypos));
        Rstrike(3,1:nhypos) = Rstrike(3,1:nhypos)-mean(Rstrike(3,1:nhypos));

        % Ddip=[ 1 0 0; 0 cos(dip)  -sin(dip) ; 0 sin(dip) cos(dip)];
        %Ddip=[ cos(dip) 0 sin(dip); 0 1  0 ; -sin(dip) 0 cos(dip)];
        Ddip=[ cos(dip) 0 -sin(dip); 0 1  0 ; sin(dip) 0 cos(dip)];

        Rdip=Ddip*Rstrike;

        Rdip(1,1:nhypos) = Rdip(1,1:nhypos)+mean(Rstrike(1,1:nhypos));
        Rdip(2,1:nhypos) = Rdip(2,1:nhypos)+mean(Rstrike(2,1:nhypos));
        Rdip(3,1:nhypos) = Rdip(3,1:nhypos)+mean(Rstrike(3,1:nhypos));

        rxp(1:nhypos)=Rdip(1,1:nhypos);
        ryp(1:nhypos)=Rdip(2,1:nhypos);
        rzp(1:nhypos)=Rdip(3,1:nhypos);

%         figure;
%         plot3(rxp,ryp,rzp,'o');
%         axis equal;
%         title('Rotation into dip');
%         xlabel('X km');
%         ylabel('Y km');
%         zlabel('Z km');

        % Take the depth to have a minimu of zero. Thi does not overright the
        % original dataset.
        
        rzp = rzp-min(rzp);
        
%         figure;
%         plot3(rxp,ryp,rzp,'o');
%         axis equal;
%         title('Rotation into dip (z adjusted)');
%         xlabel('X km');
%         ylabel('Y km');
%         zlabel('Z km');



        % ---------------------------------------------------------------
        % Analyziing the results

        % Concatenate these result with the original dataet to kep track of each
        % point. Sort the data based on the new depths.

        analy(:,4) = rxp';
        analy(:,5) = ryp';
        analy(:,6) = rzp';

        analy=sortrows(analy,6);

        % Stepwisely move through the data in depth and the number of EQs in each
        % block. we need to specify the width of the block. 

        st_array= 0:max(rzp+1); 

        for i = 1:length(st_array)
            st = st_array(i);
            index = find(analy(:,6)>=st & analy(:,6)<(st+width));

            neqs_in_window = length(index);

            for ii = 1: neqs_in_window
                if (analy(index(ii),7) < neqs_in_window) && ...
                        (neqs_in_window >= min_eqs_for_a_cluster)
                    analy(index(ii),7) = neqs_in_window;
                    analy(index(ii),8) = st;
                    analy(index(ii),9) = strike/con;
                    analy(index(ii),10) = dip/con;
                    analy(index(ii),11) = unique_value;
                end
            end    
        end
    end
end

for cluser = unique(analy(:,11))
    xsc = analy(analy(index(ii),11) == 
    ysc = 
    zsc = 



figure;
plot3(xs,ys,zs,'o');
axis equal;
title('Input Data');
xlabel('X km');
ylabel('Y km');
zlabel('Z km');

toc 

%*************************** END OF THE CODE ******************************














% for i = 1: length(st_array)
%     st = st_array(i);
%     aa(i) = length(analy(analy(:,6)>=st & analy(:,6)<=(st+width),6));
% end
% aa(aa<=20) = 0;
% plot(st_array, aa); shg

%aa(i) = length(analy(analy(:,6)>=st & analy(:,6)<=(st+width),6));
% aa(aa<=20) = 0;
% 
% plot(st_array, aa); shg
